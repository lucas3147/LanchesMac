				LANCHESMAC				

				AULA 44

OPERADORES: 

- "?." - (elvis operator) 

	Se o lado esquerdo da expressão for diferente de null, retorna o lado direito desse operador, se for null, retorna o lado direito

- "??" - (operador de coalescência nula)

	O operador de coalescência nula, ?? , retornará o valor do operando esquerdo se não for null; caso contrário, ele avaliará o operando direito e retornará seu resultado.


				AULA 54

APRESENTANDO O CONCEITO DE TAG HELPERS:


As Tag Helpers permitem que o código do lado do servidor participe na criação e renderização de elementos HTML em arquivos Razor.

Elas são uma sintaxe alternativa aos Html Helpers e obtém o mesmo resultado final gerando o código HTML
A sintaxe parece com HTML ( elementos e atributos ), mas é processadi pelo Razor no servidor

Exemplos

<input type="text" asp-for="Nome"/>

Normal: <input id="nome" name="nome" type="text" value=""/>

<label asp-for="Email"></label>

Normal: <label for="Email">Email</label>

<form asp-controller="Conta" asp-action="Login">
	// Os elementos do formulário
</form>

Normal: <form action="/Conta/Login" method="post">
	// Os elementos do formulário
	</form>

As Tags Helpers são diretivas que são definidas numa automaticamente*

A diretiva @addTagHelper torna as Tag Helpers disponíveis para uma view

Ao criar uma aplicação ASP .NET Core o arquivo Views/_ViewImports.cshtml que será herdado por todas as views da pasta /Views e subpastas.
Será criado com o seguinte o conteúdo:

@addTagHelper*, Microsoft.AspNetCore.Mvc.TagHelpers

PARA A CRIAÇÃO DE ELEMENTOS DE FORMULÁRIO TEMOS UM CONJUNTO DE TAG HELPERS DESCRITOS A SEGUIR:

-Input Tag Helper

-Text Area Tag Helper

-Validation Tag Helper

-Label Tag Helper

-Select Tag Helper

O recurso do Intellisense também está disponível para as TagHelpers.

A TAG HELPER INPUT

A Tag Helper Input vincula um elemento HTML <input> a uma expressão de modelo na sua view razor.
A sintaxe usada é:

<Input asp-for="<Nome da expressão>">

A Tag Helper Input define o atributo de tipo HTML com base nos tipos da .NET Framework.

Tipo .NET			Input Type

Bool				checkbox
String				text	
DateTime			datetime
Byte				number
Int				number
Single, Double			number

Atributos			Input Type

[EmailAddress]			email
[Url]				url
[HiddenInput]			hidden
[Phone]				tel
[DataType(DataType.Password)]	password
[DataType(DataType.Date)]	date
[DataType(DataType.Time)]	time


				AULA 55

CRIANDO UMA TAG HELPER

- Criar pasta TagHelpers

- Criar classe EmailTagHelper(herda de TagHelper)

- Sobrescerver o método Proccess(context, output)

- Criar item de menu Contato no arquiv _Layout

- Criar controlador ContatoController

- Criar método Action Index e a view Index


				AULA 57

APRESENTANDO OS CONCEITOS SOBRE ROTEAMENTO - I

ROTEAMENTO DE ENDPOINT

O roteamento é o processo pelo qual o framework ASP .NET Core inspeciona os requests HTTP de entrada e faz o mapeamento destes requests para executar os métodos Action correspondente do controlador.

Esse processo é chamado de roteamento de endpoint

RESPONSABILIDADES DO ROTEAMENTO

1 - Mapear os requests de entrada para Action do Controlador

2 - Gerar a URL de saída que corresponde às ações do Controller

ENDPOINT 

Um Endpoint é um objeto que contém tudo que você precisa para executar um Request de entrada:

1 - Os metadados do Request

2 - O delegate que a ASP .NET Core usa para processar o Request

Os endpoints são definidos pelo método UseEndpoints. [Usando a configuração feita no arquivo Startup]


				AULA 72

CONFIGURANDO O IDENTITY NO PROJETO

Microsoft.AspNetCore.Identity

É o sistema de associação que adiciona recursos de login de autenticação

Microsoft.AspNetCore.Identity.EntityFrameworkCore

É o provedor de identidade ASP .NET Core que usa o Entity Framework Core

ABORDAGEM PADRÃO

- Utilizar um banco de dados Dql Server para armazenar as informaç~eoes dos usuários como nome, senha, permissões, etc

- Criar o banco de dados e as tabelas usando a abordagem Code-First

- A nossa implementação vai criar as tabelas do Identity no Banco de dados da aplicação LancheDatabase

ARQUIVO DE CONTEXTO

- deve implementar a Interface IdentityDbContext<IdentityUser>. Desse modo:

	public class AppDbContext : IdentityDbContext<IdentityUser> {... codigo ...}

- O IdentityDbContext fornece todas as propriedades DbSet necessárias para gerenciar as tabelas de identidade no SQL Server

- A classe IdentityUser é fornecida pela ASP.NET Core e contém propriedades para UserName, PasswordHash, Email etc. Essa é a classe usada pelo Identity para gerenciar usuários registrados do seu aplicativo

- Depois de aplicar essa configuração, basta apenas aplicar o migrations e ele vai aplicar as tabelas no banco de dados

ARQUIVO STARTUP

- Applicar o seguinte código na function ConfigureServices

ConfigureServices(IServiceCollection services)
{
	services.AddIdentity<IdentityUser, IdentityRole>()
		.AddEntityFrameworkStores<AppDbContext>()
		.AddDefaultTokenProviders();
}

- IdentityRole é uma classe interna do Identity e fornece informações dsobre perfis do usuário

- AddEntityFrameworkStores - permite armazenar e recuperar informações de usuários e do perfil usando o EF Core para o SQL Server

- AddDefaultTokenProviders - Inclui provedores de token padrão para redefinir senha, alterar email, no. de telefone e geração de token para autenticação em dois fatores

- Após isso precisamos incluir um middleware de autenticação e autorização na function Configure()

public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
	app.UseAuthentication();

	app.UseAuthorization();
}

- O middleware de autenticação (UseAuthentication) tenta autenticar o usuário antes de ele ter acesso aos recursos seguros.

- Middleware de autorização (UseAuthorization) autoriza um usuário a acessar recursos seguros

				AULA 75

TAG HELPERS USADAS NA VALIDAÇÃO

1 - asp-validation-summary

	É usada para exibir um resumo das mensagens de validação no formulário

	asp-validation-summaru		Mensagem de validação exibida

	All				Propriedades e model

	ModelOnly			Model

	None				None


2 - asp-validation-for

	Anexa as mensagens de erro de validação no campo de entrada da propriedade de modelo especificada

	Quando ocorre um erro de validação do lado do cliente, o JQuery exibe a mensagem de erro no elemento <span>.

				AULA 76

IMPLEMENTADO O REGISTRO - I

AntiForgeryToken (evita ataques CSRF)

O cliente solicita uma página HTML que contém um formulário

A ASP.NET Core inclui dois tokens no response

	- Um token é enviado como um cookie HTTP cifrado

	- O outro é colocado em um campo oculto do formulário (hidden)

Os tokens são gerados aleatoriamente para que um hacker não consiga adivinhar os valores 

Quando o cliente envia o formulário, ele deve enviar os dois tokens de volta ao servidor

O cliente envia o token do cookie e o token do formulário dentro dos dados do formulário.

Se uma solicitação não incluir os dois tokens que devem ser iguais, o servidor não permitirá a solicitação.

O atributo [ValidateAntiForgeryToken] é usado para validar o token gerado na view

				AULA 78

IMPLEMENTANDO O LOGOUT

View Injection -> permite injetar dependências em uma View usando a palavra-chave @inject.

	@inject SignInManager<IdentityUser> SignManager


				AULA 79

VERIFICAR SE O USUÁRIO ESTÁ AUTENTICADO

HÁ DOIS MODOS DE FAZER

1 - Via Código

if (User.Identity.IsAuthenticated)
{
      return View();
}

      return RedirectToAction("Login", "Account");

2 - Usar o atributi [Authorize no Controller ou na Action

- permite o acesso somente de usuários autenticados


[Authorize]
public class ContatoController : Controller
{
	public IActionResult Index()
	{
		return View();
	}
}

//Verifica somente se o usuário está autenticado

[Authorize(Roles="Admin")]
public class ContatoController : Controller
{
	public IActionResult Index()
	{
		return View();
	}
}
//Verifca se o usuário está autenticado e se pertence ao perfil Admin

// Esses atributos podem também ser definidos nos mesmos níveis dos métodos Action

3 - Usar o atributo [AllowAnonymous] no controller ou na Action

- Permite o acesso a usuários não autenticados

// Esses atributos podem também ser definidos nos mesmos níveis dos métodos Action

[Authorize]
public class ContatoController : Controller
{
	public IActionResult Index()
	{
		return View();
	}

	[AllowAnonymous] 
	public IActionResult Teste()
	{
		return View();
	}
}

[AllowAnonymous]
public class ContatoController : Controller		//Permite o acesso a usuário não autenticado ao Controlador
{
	public IActionResult Index()
	{
		return View();
	}

	[Authorize]
	public IActionResult Teste()			//Perde o seu efeito pois é anulado pelo método AllowAnonymous
	{
		return View();
	}
}

Política de acesso do site

1 - Usuários não autenticados (anônimos)

	a - A página principal do site e toddas as suas opções		[AllowAnonymous]

	b - As páginas dos produtos : lanches, etc

	c - A página de Contato

2 - Usuários autenticados

	a - Incluir itens no carrinho de compra				[Authorize]

	b - Remover um item do carrinho

	C - Confirmar e finalizar o pedido

3 - Usuários do perfil Admin

	a - Acessar a área de administração

			
				AULA 80

APRESENTANDO O CONCEITO DE AREAS: CRIANDO A ÁREA ADMIN

AREAS - CONCEITOS

As áreas podem ser definidas como unidades funcionais menores em um projeto
Asp.Net Core MVC com seu próprio conjunto de controladores, views e modelos

Elas são usadas para organizar funcionalidades relacionadas em um grupo separado e ajudam a gerenciar a aplicação de uma maneira melhor separando cada aspecto funcional em diferentes Áreas

AREAS - QUANDO USAR

Quando sua aplicação for composta de múltiplos componentes funcionais de alto nível que podem ser separados logicamente

Se você deseja particionar seu projeto MVC para que cada área funcional possa ser tratada de forma independente

AREAS - CARACTERÍSTICAS

Uma aplicação ASP.NET Core MVC podem possuir qualquer número de áreas

Cada área possui seus próprios controladores, models e views

Suporta múltiplos controladores com o mesmo nome em áreas diferentes

AREAS - UTILIZAÇÃO - 1

A seguir temos que definir uma rota para trabalhar com a nova área criada :

...

app.UseEndpoints(endpoint => 
{
	endpoints.MapControllerRoute(
		name: "AdminArea",
		pattern: "{area:exists}/{controller=Admmin}/{action=Index}/{id?}");

	...
})

Configuração com um nome de área genérico que funciona para qualquer área que não estiver definida explicitamente

AREAS - UTILIZAÇÃO - 2

Definindo uma rota para uma área específica e a seguir uma rota genérica

app.UseEndpoints(endpoint => 
{
        endpoints.MapControllerRoute(
                name: "categoriaFiltro",
                pattern: "Lanche/{action}/{categoria?}",
                defaults: new { controller = "Lanche", Action = "List"});

	endpoints.MapControllerRoute(
		name: "AdminArea",
		pattern: "{area:exists}/{controller=Admmin}/{action=Index}/{id?}");

	...
})

AREAS - UTILIZAÇÃO - 3

Decorar o controlador com o atributo [Area("nome_area")] definido o nome da área

[Area("Admin")]
public class AdminCategoriasController : Controller
{
	...
}

[Area("Categorias")]
public CategoriasController : Controller
{
	...
}

Areas - Definindo links / rotas para áreas

Usar o atributo asp-area para informa que um link / rota se refere a uma área

<a class="nav-link text-light" asp-area="Admin" asp-controller="Admin" asp-action="Index">Admin</a>

<a class="nav-link text-light" asp-area="" asp-controller="Home" asp-action="Index">Home</a>

COM HTML HELPER

<a href="@Url.Action("index", "home", new {Area="admin"}>Ir para área Admin</a>

COM ACTIONLINK
@Html.ActionLink("Admin", "Index", "Home", new {area = "Admin"})

				AULA 80

ROTEIRO PARA IMPLEMENTAR O PERFIL PARA O USUÁRIO ADMIN

Implementar a ciriação de Roles e Users e atribuir o usuário ao perfil

1 - Implementar um serviço para criar os perfis ou roles : Admin e Member

	- ISeedUserRoleInitial
 	- ISeedUserRoleInitial

2 - Registrar o serviço no contêiner diferente

	services.AddScoped<ISeedUserRoleInitial, SeedUserRoleInitial>();

3 - Chamar o serviço na iniciaalização da aplicação (Program ou Startup)

	seedUserRoleInitial.SeedRoles();
	seedUserRoleInitial.SeedUsers();

4 - Alterar o códigodo método Register para atribuit os usuários ao perfil Member

	await _userManager.AddToRoleAsync(user, "Member");


				AULA 84

TESTANDO A IMPLEMENTAÇÃO DO PERFIL ADMIN

- Quando tentamos acessar a área de Admin como um usuário anônimo, é lançado um erro
 Informando que a política de autorização do usuário Admin não foi encontrada

O que aconteceu?

Como implementamos um registro de usuário dos perfis como um serviço, nós estamos implementando uma nova política de autorização baseada nas roles
e assim nós temos que registrar essa política usando o método AddAuthorization, definindo a política que eu usei, e informando que precisamos da role Admin


				AULA 88

ROTEIRO PARA OS AJUSTES NO PROJETO

	Paginação e filtro de dados de pedidos e lanches (area Admin)

	1 - Fazer a implementação via código usando somente os recursos da ASP.NET Core

	2 - Fazer a implementação usando um pacote de terceiro

		- Reflection.Mvc.Paging (Nuget)

		- Código fonte e instruções para instalação e uso

		https://github.com/sonnemaf/ReflectionIT.Mvc.Paging

		Install-Package ReflectionIT.Mvc.Paging


1 - Incluir o serviço no projeto no método ConfigureServices da classe Startup

	...
	services.AddPaging(options => 
	{
		options.ViewName = "Bootstrap4";
		options.PageParameterName = "pageindex";
	});
	...

2 - Alterar o método Action do controlador referente à view onde queremos paginar os dados

	public async Task<IAcionResult> Index(string filter, int pageIndex = 1, string sort = "Nome")
	{
		var resultado = _context.Lanches.Include (l => l.Categoria).AsQueryable();

		if(!string.IsNullOrWhiteSpace(filter))
		{
			resultado = resultado.Where(p => p.Nome.Contains(filter));
		}

		var model = await PagingList.CreateAsync(resultado, 5, pageindex, sort, "Nome");

		model.RouteValue = new RouteValueDictionary ({"filter", "filter"});

		return View(model);
	}

3 - Alterar o código da view que vai exibir os dados paginados (index.cshtml)

	@model ReflectionIT.Mvc.Paging.PagingList<LanchesMac.Models.Lanche>
	
	....
		Trecho do formulário 
	....

	Total de Lanches : @Model.TotalRecordCount
	<div>
		//Aqui eu uso  uma view component e tag helper para permitir o usuário navegar entre as páginas
		<vc: pager paging-list="@Model"></vc:pager>
	<div>

				AULA 94

IMPLEMENTANDO O GERENCIAMENTO DE IMAGENS: CONCEITOS E ABORDAGENS

UPLOAD DE ARQUIVOS

1 - Suporte com a vinculação do modelo em buffer npara arquivos menores

2 - Suporte ao streaming sem buffer para arquivos maiores

CONSIDERAÇÕES DE SEGURANÇA

Riscos

- Executar ataques de negação de serviço.

- Fazer upload de vírus ou malware.

- Comprometer a redes e servidores de outras maneiras.

Cuidados

- Fazer upload em uma área dedicada com restrição de segurança sem permissão de execução

- Não persistir os arquivos carregados na mesma área de diretório da aplicação

- Usar nome seguro de arquivo determinado pelo aplicativo (não pelo usuário)

- Permitir apenas extensões de arquivos aprovadas

- Verificar o tamanho do arquivo enviado e definir um tamanho máximo (30MB)

- Determinar uma quantidade máxima de arquivos que podem ser enviada

- Executar um antivírus no conteúdo enviado antes de armazenar o arquivo

CONSIDERAÇÕES DE ARMAZENAGEM

Banco de dados

- Indicado para arquivos pequenos

- Permite acessar toda a informação de forma única

- Facilita o gerenciamento de arquivos e backup de segurança

Sistema de arquivos

- Gerenciamento é mais barato do que um serviço de banco de dados

- Mas torna mais complexo o gerenciamento dos arquivos e o backup de segurança

- Possuem limites mais amplos que os usados em um banco de dados

GERENCIAMENTO DE IMAGENS

Consultar, enviar e deletar imagens dos produtos

1 - Definir uma pasta images/produtos para as imagens na pasta wwwroot do projeto

2 - Criar um controlador AdminImagens e implementar as seguintres funcionalidades

	a - Apresentar o formulário para exibir e enviar as imagens para a pasta de imagens

		Action Index exibe os formulários para Enviar e Exibir Imagens

	b - Selecionar imagens dos produtos e enviar para o servidor

		Action UploadFiles envia os arquivos selecionados

	c - Exibir e Excluir imagens dos produtos no servidor

		Action GetImagens exibe as imagens com um link para deletar a imagem
		
		Action DeleteFile excluir uma imagem selecionada no servidor

DEFINIR O NOME DA PASTA

1 - Criar uma seçao ConfigurationPastaImagens no arquivo appsettings.json

{
	"ConfigurationPastaImagens" : {
		"NomePastaImagensProdutos" : "images/produtos"
	},
}
...

Definir uma propriedade NomePastaImagensProdutos e atribuir o nome da pasta que vamos usar no projeto e criar no servidor

2 - Criar um arquivo ConfigurationImagens com a propriedade NomePastaImagensProdutos

public class ConfigurationImagens
{
	public string NomePastaImagensProdutos {get; set;}
}

Para poder ler o valor da propriedade no arquivo appsettings.json

REGISTRAR SEÇÃO NO ARQUIVO STARTUP

3 - Registrar a seção definida com nossa classe no Contâiner DI

public void ConfigureServices(IServiceCollection services)
{
	...
		services.Configure<ConfigurationImagens>(Configuration.GetSection("ConfigurationPastaImagens"));
	...
}

ARQUIVO FILEMANAGERMODEL

public class FileManagerModel
{
	public FileInfo[] { get; set; }
	public IFormFile IFormFile { get; set; }
	public List<IFormFile> IFormFiles { get; set; }
	public string PathImagesProduto { get; set; }
}

Define propriedades que iremos usar para gerenciar os arquivos usando os recursos: 

	FileInfo - Fornece propriedades e métodos para criar, copiar, excluir, abrir arquivos, etc;
	
	IFormFile - Representa um arquivo enviado via httprequest

	List<IFormFile> - Representa uma lista de arquivos enviados via httprequest

	PathImagesProduto - Representa a pasta onde vamos salvar as imagens

CONTROLLER ADMINIMAGENS

Injetar o serviço IOption<T> e IwebHostEnvironment no construtor

[Area("Admin")]
[Authorize(Roles = "Admin")]
public class AdminImagensController : Controller
{
	private readonly ConfigurationImagens _myConfig;

	private readonly IWebHostEnvironment _ hostingEnvironment;

	public AdminImagensController(IWebHostEnvironment hostingEnvironment, IOptions<ConfigurationImagens> myConfiguration)
	{
		_hostingEnvironment = hostingEnvironment;
		_myConfig = myCofiguration.Value;
	}
	...
}

// Para conseguir ler as informações do appSettings.json, estamos utilizando o padrão IOptions que usa uma classe para fornecer um acesso fortemente tipados a grupos de configuração que estão relacionados (no nosso caso essa classe é ConfigurationImagens), sendo assim, _myConfig já pode acessar o valor da propriedade "NomePastaImagensProdutos"

// IWebHostEnvironment fornece informações sobre o ambiente de hospedagem a onde a nossa aplicação está sendo executada


				AULA 96

EXIBINDO AS INFORMAÇÕES PARA UPLOAD

IMPORTANTE

No método Configure() em Startup.cs

Existe um middleware chamado app.UseStaticFiles(), que ao ser chamado antes do middleware app.UseAuthorization(), não estamos fazendo a verificação de autorização dos arquivos estáticos, dessa forma , os arquivos estáticos tem acesso público


				AULA 99

GERANDO GRÁFICOS COM GOOGLECHART


Gráfico das vendas totais por produto e da quantidade total por produto em um período de tempo

1 - Vendas totais por produto e quantidade total nos últimos 360 dias (gráfico de coluna)

2 - Vendas totais por produto e quantidade total nos últimos 30 dias (gráfico de barra)

3 - Vendas totais por produto e quantidade total nos últimos 7 dias (gráfico de linha)

PASSO A PASSO

1 - Criar a classe LancheGráfico na pasta Models e definir as propriedades LancheNome, LanchesQuantidade e LanchesValorTotal

2 - Criar o serviço - GráficoVendasService - para calcular o valor do total das vendas por produto e a quantidade total vendida por produto

3 - Criar o controlador - AdminGraficosController - e definir os métodos Action usando o serviço criado

4 - Criar as Views e usar o GoogleChart para gerar os gráficos com base nos dados obtidos do serviço

5 - Incluir no menu do dministração, no arquivo _Layout, as opções dos gráficcos aa serem apresentados